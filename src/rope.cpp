#include "rope.hpp"
#include <cmath>

// In a real implementation, these would be large, pre-computed const arrays
// stored in ROM/BRAM. For this prototype, we can generate them on the fly
// or use a smaller pre-computed table for testing.

// Let's define a small, illustrative pre-computed table.
// In a real scenario, this would be generated by a script for MAX_SEQ_LEN.
float rope_sin_table[MAX_SEQ_LEN][ROPE_DIM];
float rope_cos_table[MAX_SEQ_LEN][ROPE_DIM];

// A helper function to initialize the tables for simulation purposes.
// In HLS, this would not be synthesizable and is only for testing.
void init_rope_tables() {
    const double base = 10000.0;
    for (int pos = 0; pos < MAX_SEQ_LEN; ++pos) {
        for (int i = 0; i < ROPE_DIM; i += 2) {
            // Use double for precision during intermediate calculation
            double freq_d = 1.0 / std::pow(base, (double)i / ROPE_DIM);
            double theta_d = (double)pos * freq_d;
            double cos_theta_d = std::cos(theta_d);
            double sin_theta_d = std::sin(theta_d);
            
            // The pairs share the same theta
            rope_cos_table[pos][i] = (float)cos_theta_d;
            rope_sin_table[pos][i] = (float)sin_theta_d;
            rope_cos_table[pos][i+1] = (float)cos_theta_d;
            rope_sin_table[pos][i+1] = (float)sin_theta_d;
        }
    }
}


void apply_rope(sfu_data_t* q, sfu_data_t* k, int pos) {
    // The RoPE logic applies a rotation to pairs of features.
    for (int i = 0; i < ROPE_DIM; i += 2) {
        // Get the pre-computed sin and cos values for the current position and dimension
        float cos_val = rope_cos_table[pos][i];
        float sin_val = rope_sin_table[pos][i];

        if (q != nullptr) {
            // Get the two adjacent feature values from the query vector
            float q0 = q[i];
            float q1 = q[i+1];
            // Apply the rotation to the query vector part
            q[i]   = q0 * cos_val - q1 * sin_val;
            q[i+1] = q0 * sin_val + q1 * cos_val;
        }

        if (k != nullptr) {
            // Get the two adjacent feature values from the key vector
            float k0 = k[i];
            float k1 = k[i+1];
            // Apply the rotation to the key vector part
            k[i]   = k0 * cos_val - k1 * sin_val;
            k[i+1] = k0 * sin_val + k1 * cos_val;
        }
    }
}
